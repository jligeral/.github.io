---
layout: essay
type: essay
title: "Tried and Trusted"
# All dates must be YYYY-MM-DD format!
date: 2023-11-29
published: true
labels:
  - Learning
  - Meteor
---

The phrase 'best practice' is something I've come across plenty during these last few months. It's a term that describes what's generally accepted, prescribed, or most effective in professional procedures. Interestingly enough, my exposure to the phrase this year has almost exclusively been related to my time learning software engineering. I even used the phrase once when conversing with a peer about the use of `!important` rule in CSS. The thing about software engineering is that at a professional level, there exist industry standards and if we want our products to succeed, we should meet these standards. In the context of procedures for solving software design problems, software design patterns are considered the 'best practice' for achieving that.

## Dynamic Programming

I am concurrently taking a class in algorithms. It's just an introductory course in algorithms, so it's main purpose is to expose us to commonly used beginner and intermediate-level algorithms. Dynamic programming describes a set of techniques that involve breaking down a complex problem into simpler repeated subproblems. In a very loose way of making a comparison, design patterns function as 'working solutions' to recurring software design problems one should encounter at all levels of software engineering. Unlike dynamic programming which aims to optimize the efficiency of a program, software design problems emphasize more on employing tried and tested code to build an application on. In a way, design patterns do promote a level of efficiency since no one needs to reinvent the wheel, so to speak, but its greatest advantage to software engineers comes in providing them with a solution that is known to work.

## Reestablishing an appreciation for templates

I've been using templates to start creating applications for the majority of this class. The main template I grew accustomed to using was called '[meteor application template react](https://github.com/ics-software-engineering/meteor-application-template-react).' On the surface, this template was primarily used to teach us how to use Meteor to create applications and websites. Through Meteor we were all exposed to a somewhat simplified means of performing full-stack development. The month I spent working on HTML, CSS, and UI frameworks could finally be put to use, as I combined the frontend development work with a database and Javascript to create a reactive application. Throughout my time working with the Meteor-React template, I came to make a few observations about the overall structure of the application. The first observation I made during my time working with my final project. I wanted to learn how to create a chatbot using React and MongoDB since those were the tools my software engineering class primarily had me use. The tutorial I used did not use Meteor, so naturally I actively made comparisons between the design structure of the tutorial chatbot and the template I was accustomed to using. The immediate difference came in how the tutorial had two directories explicitly named 'backend' and 'frontend.' The backend directory contained the subdirectories 'models,' 'routes,' 'controllers,' and 'database.' The frontend directory contained the subdirectories 'components,' 'helpers,' and 'pages.' Looking back at the project skeleton for the meteor template, the two directories that I recognized were 'components' and 'pages,' the two directories directly involved with the user interface of the application. One of my goals while working with the tutorial was putting the backend subdirectories in a context I was more familiar with.

The separation of frontend and backend isn't explicitly stated in the meteor application template, but it does exist in multiple places, specifically with the subdirectories named 'server' and 'client.' Everything in the server directory pertains to the database and the setting up of publications and collections within the application. The client code, on the hand, simply used React to render the application and make it visible and interactable with the user. The important thing we covered earlier in the semester was the idea of separation of concerns which allows us to better protect the database and other design logic from potential attack from malicious actors. The separation also allows each concern domain to be independent of the other, providing developers an easier means of managing the different parts of the system. Returning to the tutorial I worked on, a 'controller' directory existed which contained code defining three functions to generate chat responses, send the chat responses to the user, and delete responses in the database associated to a user. Another directory called 'routes' defined actions that were to happen when certain HTTP requests were made to defined endpoint urls. These two directories used in combination with another in the frontend directory called 'api-communicator' would provide both a modular and easy to maintain architecture. Furthermore, when combined with the 'model,' MongoDB and the 'view,' React, we have something called a Model-View-Controller architecture. Working on the final project, this was something I definitely came away with, but didn't realize was an established design pattern until now.

Though I successfully created a working chatbot filled with multiple modes of authentication with the tutorial, I thought it unfair to force my final project teammates into using technologies they were largely unfamiliar with. Therefore I decided it was best to try to transcribe what I had just made into a Meteor project. Since the Meteor application template was something I felt could be reused for the project, I started to really try and understand what each part of the project's architecture was responsible for. It was then I came to really notice how the code pertaining to MongoDB was almost exclusively maintained in server directories. What didn't immediately jump out to me was where I 'controllers,' 'api-communicators,' or 'routes' existed in the template. While trying to create the chatbot in Meteor, I learned how HTTP requests can be accomplished via Meteor methods, and thus a very important function used to generate an AI chat response is done in a file called 'chat-controller' using a defined Meteor method. There were other methods defined in the file that did not involve HTTP requests, but handled the parsing of user input. In a sense, I created a controller for this application, hence the file's name. I found the routing to be primarily handled in one file called "App" in the 'layout' directory, which I observed to be separated from the 'components' and 'pages' directories much like 'server' and 'client' were. And with that I could now see how even the Meteor template employed the MVC design pattern. Again, I've been taking this architecture for granted, realizing just now it had a name.

In closing I still have plenty to learn about software design patterns. I've briefly learned about the 'singleton,' the 'observer,' and the 'prototype' in screencasts and texts. I unfortunately am not confident enough to describe my use of these in software engineering yet however. I wrote this mainly because MVC was something I definitely noticed during my work this semester. It's a pattern I feel I understand, and one I will continue to use because of that. Moving forward I'd definitely like to better understand other design patterns. After all, they not only help me create easy to scale applications, but in a team environment like the final project, they definitely help to reduce the stress of adding more to the project.
